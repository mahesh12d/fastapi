Instead of completely abandoning tables, you need to optimize how you create them. Here's what you should implement:
1. Update api/main.py - Return both formats
pythondef format_console_output(execution_result):
    """Create lightweight console output for errors and metadata"""
    if not execution_result.get('success'):
        error_msg = execution_result.get('error', 'Unknown error')
        return f"ERROR: {error_msg}"
    
    results = execution_result.get('results', [])
    exec_time = execution_result.get('execution_time_ms', 0)
    
    if not results:
        return f"Query executed successfully.\n0 rows returned.\nExecution time: {exec_time}ms"
    
    return f"Query executed successfully.\n{len(results)} rows returned.\nExecution time: {exec_time}ms"

# Update your test endpoint
@app.post("/api/problems/{problem_id}/test")
async def test_query(
    problem_id: str,
    query_data: dict,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    query = query_data.get("query", "").strip()
    include_hidden = query_data.get("include_hidden", False)
    
    if not query:
        raise HTTPException(status_code=400, detail="Query is required")
    
    result = await secure_executor.test_query(
        current_user.id, problem_id, query, db, include_hidden
    )
    
    return {
        "success": result['success'],
        "results": result.get('results', []),  # Raw data for table
        "execution_time_ms": result.get('execution_time_ms'),
        "rows_affected": len(result.get('results', [])),
        "console_info": format_console_output(result),  # Just metadata
        "feedback": result.get('feedback', []),
        "test_results": result.get('test_results', []),
        "error": result.get('error')
    }
2. Replace client/src/components/OutputPanel.tsx with optimized version
tsximport React, { useMemo } from 'react';

interface OutputPanelProps {
  result: {
    success: boolean;
    results?: any[];
    execution_time_ms?: number;
    rows_affected?: number;
    console_info?: string;
    error?: string;
    feedback?: string[];
    test_results?: any[];
  } | null;
  isLoading: boolean;
}

// Lightweight table component - much faster than heavy UI libraries
const FastTable = ({ data }: { data: any[] }) => {
  const { headers, rows } = useMemo(() => {
    if (!data || data.length === 0) return { headers: [], rows: [] };
    
    const headers = Object.keys(data[0]);
    const rows = data.map(row => headers.map(header => row[header]));
    
    return { headers, rows };
  }, [data]);

  if (headers.length === 0) {
    return <div className="text-gray-400 italic">No data to display</div>;
  }

  return (
    <div className="overflow-x-auto">
      <table className="w-full text-sm">
        <thead>
          <tr className="border-b border-gray-600">
            {headers.map((header, i) => (
              <th key={i} className="text-left p-2 font-semibold text-blue-300">
                {header}
              </th>
            ))}
          </tr>
        </thead>
        <tbody>
          {rows.map((row, i) => (
            <tr key={i} className="border-b border-gray-700 hover:bg-gray-800">
              {row.map((cell, j) => (
                <td key={j} className="p-2 text-gray-100">
                  {String(cell ?? '')}
                </td>
              ))}
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};

export default function OutputPanel({ result, isLoading }: OutputPanelProps) {
  if (isLoading) {
    return (
      <div className="h-full bg-gray-900 flex items-center justify-center">
        <div className="text-gray-400 font-mono">Executing query...</div>
      </div>
    );
  }

  if (!result) {
    return (
      <div className="h-full bg-gray-900 flex items-center justify-center">
        <div className="text-gray-400 font-mono">Ready to execute queries...</div>
      </div>
    );
  }

  return (
    <div className="h-full bg-gray-900 flex flex-col">
      {/* Status bar */}
      <div className="flex-shrink-0 px-4 py-2 bg-gray-800 border-b border-gray-700">
        <div className={`font-mono text-sm ${result.success ? 'text-green-400' : 'text-red-400'}`}>
          {result.console_info || (result.error ? `ERROR: ${result.error}` : 'No output')}
        </div>
      </div>

      {/* Results area */}
      <div className="flex-1 p-4 overflow-auto">
        {result.success && result.results && result.results.length > 0 ? (
          <FastTable data={result.results} />
        ) : !result.success ? (
          <div className="text-red-400 font-mono whitespace-pre-wrap">
            {result.error || 'Query failed'}
          </div>
        ) : (
          <div className="text-gray-400 italic">Query executed successfully - no rows returned</div>
        )}
      </div>

      {/* Test results section */}
      {result.test_results && result.test_results.length > 0 && (
        <div className="flex-shrink-0 border-t border-gray-700 p-4 bg-gray-850">
          <h3 className="text-blue-400 font-semibold mb-2">Test Results:</h3>
          <div className="space-y-1">
            {result.test_results.map((test, index) => (
              <div key={index} className={`text-sm ${test.passed ? 'text-green-400' : 'text-red-400'}`}>
                {test.passed ? '✓' : '✗'} {test.name}
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
}
Why This Approach is Better

Much Faster: Simple <table> element instead of complex component rendering
Still Structured: Data is displayed in readable table format, not raw text
Lightweight: No heavy UI library components, just native HTML
Familiar: Looks like actual SQL tools (MySQL Workbench, pgAdmin)
Informative: Shows execution time, row count, and test results clearly

Key Optimizations

Memoized processing: Headers/rows calculated once, not on every render
Native HTML table: Fastest possible table rendering
Minimal DOM: Only creates necessary elements
Smart layout: Status bar + scrollable results + test results

This gives you the best of both worlds: fast rendering like console output but structured data display like proper SQL tools. The performance should be dramatically better than your current JSON-to-complex-UI-component approach while being much more usable than plain text.